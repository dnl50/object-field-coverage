package de.adesso.objectfieldcoverage.annotation;

import java.lang.annotation.*;

/**
 * Method-level annotation used to mark test methods for which the coverage metric should be calculated. Methods
 * which are not annotated with this annotation may also be processed in case an interface implementation is present
 * which does not depend on this annotation.
 */
@Documented
@Repeatable(TestTargets.class)
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface TestTarget {

    /**
     * Specifies the tested method the annotated test method focuses on. Uses the JavaDoc notation. All parameter types
     * not in the <em>java.lang</em>* package must by fully qualified. Generic methods and constructors are supported
     * as well.
     * <p/>
     * <b>Note:</b> Constructors generated by compile-time annotation processors (e.g. Lombok)
     * are <em>not supported</em>!
     *
     * <p/>
     *
     * Let's say the tested method {@code max} in a class named {@code Test} in the <em>de.adesso</em> package
     * is defined as follows:
     *
     * <pre>
     *      public int max(int i1, int i2) {
     *          // omitted
     *      }
     * </pre>
     *
     * The corresponding target method identifier would be {@code de.adesso.Test#max(int, int)}.
     * <p/>
     * Other Examples:
     *
     * <pre>
     *     package de.adesso.example;
     *
     *     public class UserServiceImpl {
     *         public List&lt;String&gt; getUsers(Collection&lt;String&gt; userIds) {
     *             // omitted
     *         }
     *     }
     * </pre>
     *
     * The resulting target method identifier would be {@code de.adesso.example.UserServiceImpl#getUsers(java.util.Collection)}.
     *
     * @return
     *          The target method identifier in a JavaDoc notation, can not be empty.
     */
    String value();

}
