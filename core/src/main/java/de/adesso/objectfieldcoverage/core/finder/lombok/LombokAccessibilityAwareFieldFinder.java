package de.adesso.objectfieldcoverage.core.finder.lombok;


import de.adesso.objectfieldcoverage.api.AccessibilityAwareFieldFinder;
import de.adesso.objectfieldcoverage.core.finder.lombok.generator.LombokGetterMethodGenerator;
import de.adesso.objectfieldcoverage.core.finder.lombok.generator.LombokGetterMethodGeneratorImpl;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Getter;
import org.apache.commons.lang3.tuple.Pair;
import spoon.reflect.declaration.CtField;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeMember;
import spoon.reflect.declaration.CtTypedElement;
import spoon.reflect.reference.CtTypeReference;

import java.util.Collection;
import java.util.Objects;
import java.util.Set;

/**
 * {@link AccessibilityAwareFieldFinder} finding fields which are either directly annotated with Lombok's
 * {@link Getter} annotation or their declaring type is annotated with {@link Getter} or {@link Data}.
 * Eagerly generates getter methods on annotated types, even though the field the getter is generated for
 * might not accessible.
 *
 * @see LombokGetterMethodGenerator
 */
public class LombokAccessibilityAwareFieldFinder extends AccessibilityAwareFieldFinder {

    /**
     * The getter method generator which is used to generate lombok getter methods.
     */
    private final LombokGetterMethodGenerator lombokGetterMethodGenerator;

    /**
     * Default no-arg constructor initializing the internal {@link LombokGetterMethodGenerator}
     * with a {@link LombokGetterMethodGeneratorImpl}.
     */
    public LombokAccessibilityAwareFieldFinder() {
        this.lombokGetterMethodGenerator = new LombokGetterMethodGeneratorImpl();
    }

    /**
     *
     * @param lombokGetterMethodGenerator The {@link LombokGetterMethodGenerator} which should be used
     *                                    internally, not {@code null}.
     */
    public LombokAccessibilityAwareFieldFinder(LombokGetterMethodGenerator lombokGetterMethodGenerator) {
        this.lombokGetterMethodGenerator = Objects.requireNonNull(lombokGetterMethodGenerator,
                "lombokGetterMethodGenerator cannot be null");
    }

    /**
     *
     * @param accessingType
     *          The class whose methods could potentially access the given {@code type}'s
     *          fields, not {@code null}.
     *
     * @param field
     *          The field to check, not {@code null}.
     *
     * @return
     *          {@code true}, if the given field has a generated getter which is accessible
     *          by the given {@code accessingType}. {@code false} is returned otherwise.
     */
    @Override
    public boolean isFieldAccessible(CtType<?> accessingType, CtField<?> field) {
        return this.hasAccessibleGeneratedGetter(accessingType, field);
    }

    /**
     *
     * @param accessingType
     *          The type whose methods can access the given {@code field},
     *          not {@code null}.
     *
     * @param field
     *          The field which can be accessed by inside the given {@code accessingType},
     *          not {@code null}.
     *
     * @param <T>
     *          The type of the field.
     *
     * @return
     *          A set containing the getter method generated by lombok as its only
     *          element.
     *
     * @see LombokGetterMethodGenerator#generateGetterMethod(CtField, AccessLevel)
     */
    @Override
    public <T> Collection<CtTypedElement<T>> findAccessGrantingElements(CtType<?> accessingType, CtField<T> field) {
        var getterAccessLevel = getAccessLevelOfGeneratedGetter(field);
        return Set.of(lombokGetterMethodGenerator.generateGetterMethod(field, getterAccessLevel));
    }

    /**
     * This method generates a new getter method on the given {@code field}'s declaring type in case
     * no conflicting getter method is already present.
     * <p/>
     * <b>Note:</b> {@link AccessLevel#MODULE} and {@link AccessLevel#PACKAGE} are regarded as
     * equal access levels.
     *
     * @param accessingType
     *          The type whose methods could potentially access the given {@code field},
     *          not {@code null}.
     *
     * @param field
     *          The field to check, not {@code null}.
     *
     * @return
     *          {@code true}, if lombok generates a getter which is accessible from the given
     *          {@code accessingType}. {@code false} is returned otherwise.
     *
     * @see #isAccessibleAccordingToJls(CtType, CtTypeMember)
     * @see LombokGetterMethodGenerator#isGetterMethodWithDifferentAccessModifierPresent(CtField, AccessLevel)
     */
    private boolean hasAccessibleGeneratedGetter(CtType<?> accessingType, CtField<?> field) {
        if(!isFieldOrDeclaringClassAnnotatedWithGetter(field)) {
            return false;
        }

        var accessLevel = this.getAccessLevelOfGeneratedGetter(field);

        if(lombokGetterMethodGenerator.isGetterMethodWithDifferentAccessModifierPresent(field, accessLevel)) {
            return false;
        }

        var generatedGetterMethod = lombokGetterMethodGenerator.generateGetterMethod(field, accessLevel);
        return super.isAccessibleAccordingToJls(accessingType, generatedGetterMethod);
    }

    /**
     *
     * @param field
     *          The field to check, not {@code null}.
     *
     * @return
     *          {@code true}, if the given {@code field} is annotated with {@link Getter}
     *          or the fields declaring type is annotated with {@link Getter} or {@link Data}. {@code false}
     *          is returned otherwise.
     */
    private boolean isFieldOrDeclaringClassAnnotatedWithGetter(CtField<?> field) {
        if(field.getAnnotation(Getter.class) != null) {
            return true;
        }

        var declaringType = field.getDeclaringType();
        return declaringType.getAnnotation(Getter.class) != null ||
                declaringType.getAnnotation(Data.class) != null;
    }

    /**
     * See Lombok's <a href="https://projectlombok.org/features/GetterSetter">Getter</a> and
     * <a href="https://projectlombok.org/features/Data">Data</a> documentation for more details.
     *
     * @param field
     *          The field to get the access level of the generated getter for, not
     *          {@code null}.
     *
     * @return
     *          The access level specified in the Getter annotation of the field (if present),
     *          the access level specified in the Getter annotation of the declaring type (if present)
     *          or {@link AccessLevel#PUBLIC} otherwise, since the declaring type must be annotated
     *          with {@link Data} then and the access level can't be specified. Exactly in that order.
     */
    private AccessLevel getAccessLevelOfGeneratedGetter(CtField<?> field) {
        var fieldGetterAnnotation = field.getAnnotation(Getter.class);

        if(Objects.nonNull(fieldGetterAnnotation)) {
            return fieldGetterAnnotation.value();
        }

        var declaringTypeGetterAnnotation = field.getDeclaringType()
                .getAnnotation(Getter.class);
        if(Objects.nonNull(declaringTypeGetterAnnotation)) {
            return declaringTypeGetterAnnotation.value();
        }

        return AccessLevel.PUBLIC;
    }

    /**
     *
     * @param accessingTypeTypeRefPair
     *          A pair containing the accessing type and the field declaring type, not {@code null}.
     *
     * @return
     *          {@code true}, since a type can make a field accessible through several options.
     */
    @Override
    public boolean callNext(Pair<CtType<?>, CtTypeReference<?>> accessingTypeTypeRefPair) {
        return true;
    }

}
